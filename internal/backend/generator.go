package backend

import (
	"fmt"
	"os"

	"github.com/dave/jennifer/jen"
	"simplescript/internal/ast"
)

type Generator struct {
	file *jen.File
	compiler *Compiler
}

func NewGenerator(c *Compiler) *Generator {
	f := jen.NewFile("main")
	f.HeaderComment("Code generated by SimpleScript. DO NOT EDIT.")
	return &Generator{file: f, compiler: c}
}

// Transpiles the SimpleScript AST into valid Go code
func MustGenerate(compiler *Compiler, prog *ast.Program) string {
	g := NewGenerator(compiler)
	code, err := g.generate(prog)

	if err != nil {
		fmt.Printf("Generation Error: %v\n", err)
		os.Exit(1)
	}

	return code
}

func (g *Generator) generate(prog *ast.Program) (string, error) {
	g.file.Func().Id("main").Params().BlockFunc(func(b *jen.Group) {
		for _, stmt := range prog.Statements {
			g.genStatement(b, stmt)
		}
	})

	return fmt.Sprintf("%#v", g.file), nil
}

func (g *Generator) genStatement(group *jen.Group, stmt ast.Statement) {
	switch s := stmt.(type) {
	case *ast.VarDecl:
		goType := "interface{}"
		if info, ok := g.compiler.LookupVariable(s.Name); ok {
			goType = g.compiler.GetGoType(info.Type)
		}

		var stmtBuilder *jen.Statement
		if s.IsConst {
			stmtBuilder = jen.Const()
		} else {
			stmtBuilder = jen.Var()
		}

		group.Add(stmtBuilder.Id(s.Name).Id(goType).Op("=").Add(g.genExpression(s.Value)))

	case *ast.Assignment:
		target := s.Targets[0]
		val := g.genExpression(s.Values[0])
		group.Add(g.genExpression(target)).Op(s.Operator).Add(val)

	case *ast.SayStmt:
		args := []jen.Code{}

		for _, arg := range s.Args {
			args = append(args, g.genExpression(arg))
		}

		group.Add(jen.Qual("fmt", "Println").Call(args...))

	case *ast.IfStmt:
		group.Add(g.genIf(s))

	case *ast.ForStmt:
		start := g.genExpression(s.Start)
		end := g.genExpression(s.End)

		group.Add(jen.For(
			jen.Id(s.Iterator).Op(":=").Add(start),
			jen.Id(s.Iterator).Op("<").Add(end),
			jen.Id(s.Iterator).Op("++"),
		).BlockFunc(func(b *jen.Group) {
			g.genStatement(b, s.Body)
		}))

	case *ast.Block:
		for _, bStmt := range s.Statements {
			g.genStatement(group, bStmt)
		}
	}
}

func (g *Generator) genIf(s *ast.IfStmt) *jen.Statement {
	cond := g.genExpression(s.Condition)

	ifStmt := jen.If(cond).BlockFunc(func(b *jen.Group) {
		g.genStatement(b, s.Consequence)
	})

	if s.Alternative != nil {
		if altIf, ok := s.Alternative.(*ast.IfStmt); ok {
			ifStmt.Else().Add(g.genIf(altIf))
		} else {
			ifStmt.Else().BlockFunc(func(b *jen.Group) {
				g.genStatement(b, s.Alternative)
			})
		}
	}

	return ifStmt
}

func (g *Generator) genExpression(expr ast.Expression) jen.Code {
	switch e := expr.(type) {
	case *ast.IntegerLiteral: return jen.Lit(int(e.Value))
	case *ast.FloatLiteral: return jen.Lit(e.Value)
	case *ast.StringLiteral: return jen.Lit(e.Value)
	case *ast.BooleanLiteral: return jen.Lit(e.Value)
	case *ast.ListLiteral:
		elements := []jen.Code{}

		for _, el := range e.Elements {
			elements = append(elements, g.genExpression(el))
		}

		return jen.Index().Interface().Values(elements...)
	case *ast.Identifier: return jen.Id(e.Value)
	case *ast.PrefixExpression: return jen.Op(e.Operator).Add(g.genExpression(e.Right))
	case *ast.InfixExpression: return jen.Parens(jen.Add(g.genExpression(e.Left)).Op(e.Operator).Add(g.genExpression(e.Right)))
	case *ast.IndexExpression: return jen.Add(g.genExpression(e.Left)).Index(g.genExpression(e.Index))
	default: return jen.Null()
	}
}
